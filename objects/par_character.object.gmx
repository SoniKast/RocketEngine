<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_mask_main</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>ctr_indestructible</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Main variables.

 // Flag, checking if everything has been initialized. Prevents possible errors:
 // _____________________________________________________________________________________________________________________________ 
 
    is_initialized = false;

 // ID:
 // _____________________________________________________________________________________________________________________________ 
  
    character_id     = global.character_index; // &gt; The character we're playing as.
    character_is_cpu = false;                  // &gt; Is the character a CPU?

 // State:
 // _____________________________________________________________________________________________________________________________ 
 
    state          = 1; // &gt; The characters current state.
    previous_state = 0; // &gt; Characters previous state.
    state_timer    = 0; // &gt; Keeps track how long the character is in a state. Only used for certain states.
    physic_state   = 0; // &gt; Characters physic state. (0 &gt; Default, 1 &gt; Underwater)
    player_state   = PLAYER_NORMAL; // State of our Character, either Normal (Default), Super or Hyper.
        
 // Flags:
 // _____________________________________________________________________________________________________________________________ 
 
    f_launch_angle     = 90; // &gt; The angle used after leaving a ramp/slope. Defined by the tiles creation event. Defaults at 90.   
    f_launch_allow     = 1;  // &gt; Checks if the character can launch on a tile.
    f_launch_direction = 1;  // &gt; Prevents the character from launching when not moving towards the tiles launch direction.
    f_angle_change     = 0;  // &gt; Flag used to rotate the character at certain angles on tiles. Defined by the tiles creation event. Default 1.
    f_edge_skip        = 0;  // &gt; Skips edge collision checking to prevent getting stuck on certain tiles after landing on them (such as quarter ellipes). Defined by the tiles creation event. Default 0.
    f_ceiling_movement = 0;  // &gt; When set to 1, the character is allowed to adapt and move on the ceiling. Set to 0 to prevent that.
    f_edge_exception   = 0;  // &gt; Prevent the character from grabbing a angle of 90/270 on edges.
    
 // Movement variables.
 // Horizontal / X:
 // _____________________________________________________________________________________________________________________________
 
    x_allow         = true;     // &gt; Whether or not the character can move horizontally.
    x_speed         = 0;        // &gt; The (current) horizontal speed.
    x_speed_top     = 6;        // &gt; How fast the character can move while on flat ground.
    x_speed_max     = 16;       // &gt; Fastest the character can move horizontally.
    x_speed_limit   = false;    // &gt; Whether or not to limit the characters horizontal speed. You probably wanna keep this off.
    x_acceleration  = 0.047875;  // &gt; The horizontal acceleration while grounded.
    x_deceleration  = 0.5;      // &gt; The horizontal deceleration while groundedn.
    x_slope_factor  = 0.125;    // &gt; Rate at which the character slows down on slopes.
    x_air_accel     = 0.09375;  // &gt; The horizontal acceleration while in air.
    x_temp_accel    = 0;        // &gt; Stores the acceleration value temporarily.
    x_temp_decel    = 0;        // &gt; Stores the deceleration value temporarily.
    x_temp_friction = 0;        // &gt; Stores the friction value temporarily.
    g_speed         = 0;        // &gt; Stores the ground speed.
    
 // Vertical / Y:
 // _____________________________________________________________________________________________________________________________ 
 
    y_allow               = true;    // &gt; Whether or not the character can move vertically.
    y_speed               = 0;       // &gt; The (current) vertical speed.
    y_speed_max           = 16;      // &gt; Fastest the character can move vertically.
    y_speed_limit         = false;   // &gt; Whether or not to limit the characters vertical speed. You probably wanna keep this off.
    y_acceleration        = 0.14675; // &gt; The force of gravity applied to the character.
    y_common_acceleration = 0.14675; // &gt; Stores the original acceleration value for quick access.
    y_conversion          = 1;       // &gt; Speed conversion when landing on slopes.
    
 // Speed samples:
 // &gt; Used to prevent the character from loosing collision when he goes beyond his max speed. Pixel limit to divide horizontal and vertical movement.
 // _____________________________________________________________________________________________________________________________ 
 
    x_sample = 13; 
    y_sample = 13; 
    
 // Terrain / Collision variables:
 // _____________________________________________________________________________________________________________________________ 
 
    ground           = false; // &gt; Checks if the character is grounded.
    collision_layer  = 0;     // &gt; The current terrain layer. Used for various things like loops.
    floor_mode       = 0;     // &gt; The current floor mode (0 to 4). Used for various things like launching off slopes.
    slope_ang_mode   = 0;     // &gt; Slope angle mode. Used for slope helper.
    platform_mode    = true;  
    platform_id      = noone; // &gt; The id of the platform we're grounded on.
    platform_check   = 0;     // &gt; Checks if teh characters is grounded on a platform.
    platform_timer   = 30;    // &gt; Used to reset the platform check. Preventing that the character can get stuck or bump off platforms.
    swing_id         = noone; // &gt; The id of the swing platform we're grounded on.
    disable_wallstop = false; // &gt; If true, we disable the horizontal speed stop after hitting a wall. This is required for launching on slopes.
    
 // Angle variables:
 // _____________________________________________________________________________________________________________________________ 
 
    angle          = 0; // &gt; The (current) angle of the character while grounded. Not related to the animation angle.
    angle_round    = 0; // &gt; The (current) rounded angle of the character while grounded.
    angle_relative = 0; // &gt; The (current) relative to gravity angle of the character.
    angle_hold     = 0; // &gt; Used to smoothen angle values.
    angle_previous = 0; // &gt; Stores the previous angle.

 // Speed shoes:
 // _____________________________________________________________________________________________________________________________ 
 
    speedshoe_state = 0; // &gt; Checks if we're using the speed shoes.
    speedshoe_timer = 0; // &gt; How long speed shoes last.
    
 // Input Flags:
 // _____________________________________________________________________________________________________________________________ 
 
    input_alarm     = 0; // &gt; Input alarm, used to prevent the character from receiving input when sliding down slopes.
    input_alarm_dir = 0; // &gt; The direction that we want to lock.
    move_alarm      = 0; // &gt; Alarm thingy
    input_lock_l    = 0; // &gt; Locks input to the left.
    input_lock_r    = 0; // &gt; Locks input to the right.
    input_lock_s    = 0; // &gt; Locks input after using a spring.
    launch_lock     = 0; // &gt; Locks the horizontal speed while launching. (Depends on terrains launch method)
    tunnel_lock     = 0; // &gt; Locks the character while inside tunnels.
    flipper_lock    = 0; // &gt; Locks the character while on a flipper.
    lock_timer      = 0;
    
 // Crouching / Looking:
 // _____________________________________________________________________________________________________________________________ 
 
    up_timer   = 0; // &gt; Timer while looking up. Used for camera shifting.
    down_timer = 0; // &gt; Timer while looking down. Used for camera shifting.
    allow_look = 1; // &gt; Allows the character to crouch and look up.
    
 // Shields:
 // _____________________________________________________________________________________________________________________________ 
 
    shield_index  = 0;     // &gt; The current shield the character uses.
    shield_object = noone; // &gt; Sets the shield object.
    shield_usable = 0;     // &gt; Checks if a shield is usable (Used for special actions)
    shield_state  = 0;     // &gt; The state of the shield. 
    cloud_bounce  = false;     // &gt; Cloud Bounce
    
 // Invincibility:
 // _____________________________________________________________________________________________________________________________ 
 
    invincibility       = 0; // &gt; Checks if the character is invulnerable to damage. (0 = No. 1 = After getting hit. 2 = Invincibility or super form)
    invincibility_timer = 0; // &gt; How long invincibility lasts.
    
 // Position:
 // _____________________________________________________________________________________________________________________________ 
 
    previous_x = 0; // &gt; Stores the previous x position.
    previous_y = 0; // &gt; Stores the previous y position.
 
 // Underwater flags:
 // _____________________________________________________________________________________________________________________________ 
 
    drown_timer   = 1800;  // &gt; how long it takes until we're drowning.
    drown_counter = noone; // &gt; Keeps track of the counter instance.
    bubble_timer  = 0;     // &gt; How long the character stays in the air after getting a air bubble.
    breath_timer  = 40;    // &gt; Used to spawn bubbles after drowning.
    has_drowned   = false; // &gt; Checks if we've drowned.
    
 // Jumping:
 // _____________________________________________________________________________________________________________________________ 
 
    jump_strength  = -5.4453;   // &gt; Max. jumping strength.
    jump_release   = -2.124;    // &gt; Min. jumping strength.
    jump_completed = false; // &gt; Checks if the character completed their jump.
    jump_lock      = false; // &gt; Whether or not horizontal input is locked while jumping.
    
 // Rolling, Spindashing, Drop Dash and Peelout:   
 // _____________________________________________________________________________________________________________________________
  
    spindash_animation = 0;         // &gt; Checks the animation state of the spindash dust.
    spindash_frame     = 0;         // &gt; Current sprite frame of the spindash dust. 
    spindash_strength  = 0;         // &gt; Current strength of the spindash.
    spindash_pitch     = 1;         // &gt; Used to change the spindash charging sound effect.
    roll_deceleration  = 0.125;     // &gt; Base deceleration value while rolling.
    roll_friction      = 0.0234375; // &gt; Friction while we're rolling.
    roll_decel_up      = 0.078125;  // &gt; Deceleration while rolling up slopes.
    roll_decel_down    = 0.3125;    // &gt; Deceleration while rolling down slopes.  
    roll_rebounce      = false;     // &gt; Check if we fully rebounce off a enemy/monitor.
    dropdash_state     = 0;         // &gt; Current drop dash state. (0 = Null, 1 = Charging, 2 = Ready)
    dropdash_timer     = 0;         // &gt; Used to charge the drop dash.    
    dropdash_speed     = 8;         // &gt; The base speed for the drop dash.
    dropdash_max_speed = 12;        // &gt; The top speed for the drop dash.
    peelout_flag       = 0;         // &gt; Used to keep the character in their figure 8 animation after performing it.
    peelout_timer      = 0;         // &gt; Used while charging the figure 8 move.
    sommersault_state  = 0;         // &gt; Used to check which state the sommersault is at (0 = Null, 1 = Roll, 2 = Flip, 3 = Slide)
    sommersault_timer  = 0;         // &gt; it's a timer dummy
    goal_state         = 0;         // &gt;
    pull_timer         = -1;        // &gt;
    pull_speed         = 0;         // &gt; 
    pull_delay         = 0;         // &gt;
    spring_force       = "weak";    // &gt; "strong" = normal spring anim / "weak" = corkscrew spring anim
    rail_collision     = false;
    rail_timer         = -1;
    
 // Skidding:
 // _____________________________________________________________________________________________________________________________
  
    skid_direction  = 0;  // &gt; The direction we're skidding towards.
    skid_dust_timer = 3; // &gt; How many frames it takes to spawn a new dust particle.
    
 // Pushing:
 // _____________________________________________________________________________________________________________________________
  
    push_id        = noone; // &gt; The instace we're pushing.
    push_timer     = 0;     // &gt; Used to trigger the pushing state. 
    push_timer_max = 3      // &gt; The amount of time it takes to start pushing.
    
 // Miles variables:
 // _____________________________________________________________________________________________________________________________
 
    miles_flight_timer    = 0;     // &gt; How long we've been flying.
    miles_flight_duration = 480;   // &gt; How long we can fly.
    
    miles_tail_sprite     = noone; // &gt; Sprite for Miles tail.
    miles_tail_frame      = 0;     // &gt; Current tail frame.
    miles_tail_speed      = 0;     // &gt; Animation speed for the tail. 
    miles_tail_x          = 0;     // &gt; X Position for the tail.
    miles_tail_y          = 0;     // &gt; Y Position for the tail.
    miles_tail_angle      = 1;     // &gt; Angle of the tail. 
    miles_tail_direction  = 1;     // &gt; Direction of the tail.        
    
 // Knuckles variables:
 // _____________________________________________________________________________________________________________________________
 
    glide_top_speed    = 24;    // &gt; Fastest Knuckles can move horizontally while gliding.
    glide_gravity      = 0.115; // &gt; The gravity used while gliding.
    glide_crouch_timer = 15;    // &gt; How long knuckles stays in his crouched state (after a drop)
    glide_turn_s       = 0;     // &gt; Special variable for turning knuckles sprite.
    glide_turn_a       = 0;     // &gt; ^^ 
    climb_ox           = 0;     // &gt; Position that returns the x position when grabbing. If it increases or decreases, we stop climbing.
    climb_speed        = 0.65;     // &gt; How fast Knuckles can climb up a wall.
    is_ledge_grabbing  = 0;     // &gt; Returns if we're ledge climbing.      
    combo_state        = 0;   
    combo_alarm        = 0;
    cant_move          = true;
    
 // Amy variables:
 // _____________________________________________________________________________________________________________________________
 
    amy_hammer_attack    = 0;    // Sets the Hammer attack for Amy. (0 = No attack, 1 = Standing Attack, 2 = Running Attack, 3 = Air Attack)
    amy_roll_jump        = 0;    // Used to change Amy's animation.
    amy_hammer_jump      = 0;    // Used when doing a hammer jump.
    amy_dash_direction   = 0;    // Used when doing a hammer dash.
      
 // Shadow variables:
 // _____________________________________________________________________________________________________________________________
    
    homing_target       = noone;             // Keeps track of the target object.
    homing_mode         = 0;                 // Set the homing mode. (0 = Normal, 2 = Utopia like) (Utopia like = Sonic doesn't come to a full stop after homing into a badnik or spring. Disabled for Monitors.)
    homing_speed        = 12;                // The speed at which Sonic should move towards a homing target.
    homing_distance     = 128;               // The max. distance to find a homing target.
    homing_target_id[0] = par_monitor; 
    homing_target_id[1] = par_badnik;
    homing_target_id[2] = par_spring;
    
 // Transform variables:
    allow_transformation = 1;
    transform_ended      = 0;
    transform_timer      = 15;
 
 // Palette position:
    palette_position    = 0;
    
 // Misc.:
 // _____________________________________________________________________________________________________________________________
    
    death_timer       = -5;   // &gt; See death script in the step event. 
    afterimage_draw   = false;// &gt; Should we draw a afterimage?
    afterimage_timer  = 0;    // &gt; Timer that prevents the spawning of another afterimage.

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation variables.
 // This script will create variables for the animation system.
  
    animation_index           = "ROLL";
    animation_previous        = "";
    animation_flag            = "START";
    animation_sprite_id       = spr_char_sonic_stand;
    animation_speed           = 0;
    animation_rendering_speed = 0;
    animation_frame           = 0;
    animation_end             = 0;
    animation_loop            = 0;
    animation_loop_timer      = 0;
    animation_next            = "";
    animation_next_frame      = 0;
    animation_direction       = 1;
    animation_angle           = 0;
    animation_angle_mod       = 0;
    animation_blend           = c_white;
    animation_alpha           = 1;
    animation_timer           = 0; 
    draw_x                    = x;
    draw_y                    = y;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inputs keys.
 
    input_up               = false;
    input_down             = false;
    input_right            = false;
    input_left             = false;
    input_action           = false;
    input_special          = false;
    
    input_up_pressed       = false;
    input_down_pressed     = false;
    input_right_pressed    = false;
    input_left_pressed     = false;
    input_action_pressed   = false;
    input_special_pressed  = false;    
    
    input_up_released      = false;
    input_down_released    = false;
    input_right_released   = false;
    input_left_released    = false;
    input_action_released  = false;
    input_special_released = false;    
    
    input_up_count      = 0; input_up_mtimer      = 0;
    input_down_count    = 0; input_down_mtimer    = 0;    
    input_left_count    = 0; input_left_mtimer    = 0;
    input_right_count   = 0; input_right_mtimer   = 0;   
    input_action_count  = 0; input_action_mtimer  = 0;
    input_special_count = 0; input_special_mtimer = 0;  
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Finish initialization / Checkpoint respawn and camera.

 // Set the init. flag. Allowing other scripts to run.
    is_initialized = true;

 // Set checkpoint position.
    if(global.checkpoint_x != -1)
    {
       global.game_time = global.checkpoint_t;
       x                = global.checkpoint_x;
       y                = global.checkpoint_y;
    }
          
 // Create the camera.
    camera = instance_create(x, y, ctr_camera);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>pull_delay = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Decrease Rings.
    global.crings -= 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Revert wall stop.
 
    disable_wallstop = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep within boundaries

    if(x &lt;= (camera.limit_left+sprite_get_width(MASK_MAIN)/10) &amp;&amp; x_speed &lt; 0.0)
    {
       if(state != CS_GLIDE)
       {
          x_speed = 0;
       }
       else
       {
          if(x_speed &lt; -4) x_speed = -4;
       }
       x = (camera.limit_left+sprite_get_width(MASK_MAIN)/10);
       if(ground)
       {
          animation_index = "IDLE";
       }
    }
    else
    if(x &gt;= (camera.limit_right-sprite_get_width(MASK_MAIN)/10) &amp;&amp; x_speed &gt; 0.0)
    {
       if(state != CS_GLIDE)
       {
          x_speed = 0;
       }
       else
       {
          if(x_speed &gt; 4) x_speed = 4;
       }
       x = (camera.limit_right-sprite_get_width(MASK_MAIN)/10);
       if(ground)
       {
          animation_index = "IDLE";
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Trigger animation / Modify animation variables.
 // Here we change which animation should play at any time.
 
 // Set drawing cordinates:
    draw_x = x;
    draw_y = y;
    
 // Assign tail:
    if(character_id = CHAR_TAILS)
    {
        bv_tail_animation_setup();
    }
    
 // Apply animations.
 
 // Standing, Idling:
    if(ground == true)
    {
       if(state == CS_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; animation_index != "SKID TURN" &amp;&amp; animation_index != "CROUCH UP" &amp;&amp; animation_index != "LOOK END" &amp;&amp; animation_index != "TURN")
       { 
          if(animation_index != "STAND" &amp;&amp; animation_timer &lt; 288) bv_apply_animation("STAND");
          if(animation_index != "IDLE" &amp;&amp; animation_timer = 288) bv_apply_animation("IDLE");
       }
       
       if(state == CS_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; animation_direction = 1)
       {
           if(input_left)
           {
              animation_direction = -1;
              bv_apply_animation("TURN");
           }
       }
       if(state == CS_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; animation_direction = -1)
       {
           if(input_right)
           {
              animation_direction = 1;
              bv_apply_animation("TURN");
           }
       }
    }
    
 // Standing state timer, to change to idle animations.
    if(character_id == CHAR_SONIC || character_id == CHAR_KNUX || character_id == CHAR_SHADOW)
    {
        if(animation_index == "STAND")
        {
           if(animation_timer &lt; 288) {  animation_timer += 1; }
        }
        else
        {
           if(animation_index = "IDLE")
           { 
              animation_timer = 288;
           }
           else
           {
              animation_timer = 0;
           } 
        }
    }
    
 // Walking, Running &amp; Peelout:
    if(state == CS_DEFAULT &amp;&amp; x_speed &lt;&gt; 0 &amp;&amp; animation_index != "SKID TURN" &amp;&amp; animation_index != "TURN" &amp;&amp; animation_index != "SPEAR" &amp;&amp; animation_index != "SWIPE")
    {
        if(ground == true)
        {
            if(abs(x_speed)  &lt; 4.75) { bv_apply_animation("WALK", "SKID TURN", "PEELOUT"); { bv_apply_animation_speed(min(1, max(0.2+abs(x_speed)*0.05)));} }
            if(abs(x_speed) &gt;= 4.75) 
            { 
                bv_apply_animation("RUN",  "SKID TURN", "PEELOUT"); 
                if(character_id != CHAR_SHADOW)
                { 
                    bv_apply_animation_speed(0.20+abs(x_speed)/25);
                } 
                else
                {
                    bv_apply_animation_speed(abs(x_speed)/28);
                }
            }  
        }
    }
    
 // Jumping / Rolling:
    if(character_id != CHAR_AMY)
    {
        if(state == CS_JUMP) 
        { 
           bv_apply_animation("ROLL", "CORKSCREW");
              
           // Align the roll animation.
              if(ground)
              {
                 bv_align_roll_animation();
              }
        }
        if(state == CS_ROLL)
        {
            bv_apply_animation("ROLL");
              
           // Align the roll animation.
              if(ground)
              {
                 bv_align_roll_animation();
              }
        }
    }
    else
    {
        if(state == CS_JUMP)
        { 
           bv_apply_animation("JUMP");
              
           // Align the roll animation.
              if(ground)
              {
                 bv_align_roll_animation();
              }
        }
    }
                
 // Look up:
    if(state == CS_LOOK)
    {
       bv_apply_animation("LOOK");
    }
    
 // Crouching.
    if(state == CS_CROUCH)
    {
       bv_apply_animation("CROUCH");
    }
    
 // Air dash:
    if(state == CS_AIR_DASH)
    {
        bv_apply_animation("AIR DASH");
    }
    
 // Spindash.
    if(state == CS_SPINDASH)
    {
       bv_apply_animation("SPINDASH", "SPINDASH REV");
    } 

 // Spring Twirl.
    if(state == CS_SPRING &amp;&amp; y_speed &lt;= 0 &amp;&amp; spring_force = "strong")
    {
        bv_apply_animation("SPRING");
    }
    else if(state == CS_SPRING &amp;&amp; y_speed &gt; 0 &amp;&amp; spring_force = "strong")    
    {
        bv_apply_animation("FALL");
    }
    if(state == CS_SPRING &amp;&amp; y_speed &lt;= 0 &amp;&amp; spring_force = "weak")
    {
        bv_apply_animation("SPRING2");
    }
    else if(state == CS_SPRING &amp;&amp; y_speed &gt; 0 &amp;&amp; spring_force = "weak")    
    {
        bv_apply_animation("FALL SHORT");
    }
    
 // Diag spring
    if(state == CS_SPRING_DIAGONAL &amp;&amp; y_speed &lt;= 0)
    {
        bv_apply_animation("SPRING2");
    }
    else if(state == CS_SPRING_DIAGONAL &amp;&amp; y_speed &gt; 0)
    {
        bv_apply_animation("FALL SHORT");
    }
    
 // Pushing:
    if(state == CS_PUSH)
    {
       bv_apply_animation("PUSH");
    } 
    
 // Transform:
    if(state == CS_TRANSFORM)
    {
        bv_apply_animation("TRANSFORM");
    }
 
 // Hurt.
    if(state == CS_HURT)
    {
       bv_apply_animation("HURT");
    }
    
 // Death / Drown.
    if(state == CS_DEATH)
    {
       if(physic_state == 0)
       {
          bv_apply_animation("DIE");
       }
       else
       {
          bv_apply_animation("DROWN");
       }
    }
    
 // Goal
    if(state == CS_GOAL &amp;&amp; goal_state = 0)
    {
        bv_apply_animation("GOAL");
        bv_apply_animation_speed(min(1, max(0.2+abs(x_speed)*0.05)));
    }
    else if(state == CS_GOAL &amp;&amp; goal_state = 1)
    {
        bv_apply_animation("RUN");
        bv_apply_animation_speed(min(1, max(0.2+abs(x_speed)*0.05)));
    }
    
 // Flying / Swimming.
    if(state == CS_FLY)
    {
       if(physic_state == 0)
       {
          bv_apply_animation("FLY");
       }
       else
       {
          bv_apply_animation("SWIM");       
       }
    }
    if(state == CS_FLYDROP)
    {
       if(physic_state == 0)
       {
          bv_apply_animation("FLY DROP")
       }
       else
       {
          bv_apply_animation("SWIM DROP")       
       }
    }    
    
 // Gliding.
    if(state == CS_GLIDE &amp;&amp; !ground)
    {
        if(physic_state == 0)
        {
            bv_apply_animation("GLIDE", "GLIDE TURN", "GLIDE TURN END");
        }
        else
        {
            bv_apply_animation("SWIM", "GLIDE TURN", "GLIDE TURN END");
        }
    } 
              
 // Glide drop.
    if(state == CS_GLIDE_DROP &amp;&amp; !ground)
    {
       bv_apply_animation("GLIDE DROP");
    } 
    
 // Climbing.
    if(state == CS_CLIMB &amp;&amp; is_ledge_grabbing == 0)
    {
       if(y_speed == 0)
       {
            bv_apply_animation("CLIMB IDLE");
       }           
       else
       {
            bv_apply_animation("CLIMB");
       }
    }
    else if(state == CS_CLIMB &amp;&amp; is_ledge_grabbing == 1) 
    {
        bv_apply_animation("CLIMB LEDGE");
    }
    
 // Swipe
    if(state == CS_SWIPE)
    {
        bv_apply_animation("SWIPE");
    }
    
 // Swipe
    if(state == CS_SPEAR)
    {
        bv_apply_animation("SPEAR");
    }
    
 // Slide.
    if(state == CS_SLIDE)
    {
        bv_apply_animation("SLIDE");
    }
    
 // Pull.
    if(state == CS_PULL)
    {
        bv_apply_animation("PULL UP");
    }
    
 // Hammer Punch Animation:
    if(amy_hammer_attack = 1)
    {
        bv_apply_animation("HAMMER PUNCH");
    }
    
 // Hammer Spin Animation:
    if(amy_hammer_attack = 2)
    {
       bv_apply_animation("HAMMER SPIN");
    }     
       
 // Hammer Jump:
    if(amy_hammer_attack = 3)
    {
       bv_apply_animation("HAMMER AIR");
    }
       
 // Hammer Flip:
    if(amy_hammer_attack = 4 &amp;&amp; animation_index != "JUMP")
    {
       bv_apply_animation("HAMMER FLIP");
    }
    
 // Hammer Punch 2 Animation:
    if(amy_hammer_attack = 5)
    {
        bv_apply_animation("HAMMER PUNCH 2");
    }           
    
 // Cloud Bounce
    if(cloud_bounce = true)
    {
        bv_apply_animation("WALK");
    }
    
 // Short Hop
    if(state == CS_SHORT_HOP)
    {
        bv_apply_animation("SHORT HOP");
    }
    
 // Dive
    if(state == CS_DIVE)
    {
        bv_apply_animation("DIVE","DIVE END");
    }
    
 // Swim
    if(state == CS_STROKE)
    {
        bv_apply_animation("STROKE");
    }
    if(state == CS_STROKE_LOOK)
    {
        bv_apply_animation("STROKE LOOK");
    }
    
 // Goal Capsule
    if(state == CS_GOAL_CAPSULE)
    {
        bv_apply_animation("GOAL CAPSULE");
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation system.
 // Plays and updates the animation state of the character.
 
    if(is_initialized)
    { 
       if(animation_index != "") // Check if there's a animation to play.
       {
          // Check if we changed our animation and (re)start playback:
             if(animation_index != animation_previous)
             {
                animation_previous = animation_index;
                animation_flag     = "START";
                animation_frame    = 0;
             }
             
          // Start the playback of the animation:
             if(animation_flag == "START")
             {
                bv_update_animation_index();
                animation_flag = "PLAY";
             }

          // Play the animation:
             if(animation_flag == "PLAY")
             {
                // Animate:
                   animation_frame += animation_speed;
                
                // Check if the animation has ended:                   
                   if(floor(animation_frame) &gt; animation_end)
                   { 
                      // See if the animation loops indefinitely:
                         if(animation_loop != -1)
                         {
                            // Revert back to starting frame:
                               if(animation_loop_timer == -1)
                               {
                                  animation_frame = animation_loop;
                               }
                               else // Repeat the animation a certain amount of times.
                               {
                                    if(animation_loop_timer &gt; 1)
                                    {
                                       animation_loop_timer -= 1;
                                       animation_frame       = animation_loop;
                                    }
                                    else // End playback.
                                    {
                                       animation_frame = animation_end;                            
                                       animation_flag  = "END";                                    
                                    }
                               }
                         } 
                         else // End playback.
                         {
                            animation_frame = animation_end;    
                            animation_flag  = "END";                     
                         }
                   }
             }
             // End animation playback / Switch to animation:
             if(animation_flag == "END")
             {
                if(animation_next != "")
                {
                   animation_flag  = "PLAY";                  
                   animation_index = animation_next; 
                   animation_frame = animation_next_frame;                                                    
                   bv_update_animation_index();                                                  
                }
             }
       }
    }    
   
 // Tail animation speed. 
    if(miles_tail_sprite != noone)
    {
       miles_tail_frame += miles_tail_speed;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation Direction.
 // Defines how the facing direction changes per animation.
 
 // Change direction depending on input and speed:
    if(is_initialized)
    {
       if(state != CS_SPINDASH &amp;&amp; state != CS_LOOK    &amp;&amp; state != CS_CROUCH
       &amp;&amp; state != CS_ROLL     &amp;&amp; state != CS_SKID    &amp;&amp; state != CS_JUMP
       &amp;&amp; state != CS_HURT     &amp;&amp; state != CS_CLIMB   &amp;&amp; state != CS_GRIND)
       {
             if(input_left  &amp;&amp; x_speed &lt;= 0) { animation_direction = -1; }
             if(input_right &amp;&amp; x_speed &gt;= 0) { animation_direction =  1; }
       }

    // Skid Turn:
       if(animation_index == "SKID TURN")
       {
          if(x_speed &gt; 0) { animation_direction = -1; }
          if(x_speed &lt; 0) { animation_direction =  1; }
       }
    
    // Rolling direction:
       if(state == CS_ROLL)
       {
          // Change direction depending on input and speed:            
             if(x_speed &gt; 0 &amp;&amp; input_right) { animation_direction  =  1; }
             if(x_speed &lt; 0 &amp;&amp; input_left)  { animation_direction  = -1; }         
       }

    // Jumping direction:
       if(state == CS_JUMP &amp;&amp; !jump_lock || state == CS_SPRING || state == CS_SPRING_DIAGONAL)
       {
         // Change direction depending on input:
            if(input_right) { animation_direction =  1; } 
            if(input_left)  { animation_direction = -1; }
            if(input_left &amp;&amp; input_right)
            {
               animation_direction = animation_direction;
            }
       }

     // Change direction in the air:
        if(!ground &amp;&amp; state = CS_DEFAULT)
        {     
           // Change direction depending on input:
              if(input_right) { animation_direction =  1; }  
              if(input_left)  { animation_direction = -1; }                         
        } 
     }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite rotation.
 // This is used for rotating the players sprite.

 // Exit if not initialized, death or hurt.
    if(is_initialized == true &amp;&amp; state != CS_DEATH &amp;&amp; state != CS_HURT &amp;&amp; state != CS_FLY &amp;&amp; state != CS_FLYDROP &amp;&amp; state != CS_GLIDE &amp;&amp; state != CS_CLIMB &amp;&amp; state != CS_GLIDE_DROP &amp;&amp; state != CS_CROUCH &amp;&amp; state != CS_LOOK &amp;&amp; cloud_bounce == false)
    {
 
     // Change animation angle values:
        switch(animation_index)
        { 
            case "STAND":
            case "IDLE":
            case "ROLL":
            case "SKID":
            case "SKID TURN":
            case "SPINDASH":
            case "CROUCH":
            case "CROUCH UP":
            case "LOOK":
            case "LOOK END":
            case "CLIMB LEDGE":
            case "GRIND":
            case "GRIND LOWER":
            case "HAMMER PUNCH":
            case "HAMMER PUNCH 2":
            case "HAMMER AIR":
            case "HAMMER SPIN":
            case "HAMMER FLIP":
            case "SPEAR":
            case "GOAL":
            case "SOMMERSAULT A":
            case "SOMMERSAULT B":
            case "SLIDE":
            case "COMBO A":
            case "COMBO B":
            case "COMBO FINISH":
            case "SWIPE":
            animation_angle = global.gravity_angle;
            break;
            default:
            if (ground)
            {
                //interpolate new angle when on small angle changes (resolves thikering in slopes)
                if(bv_character_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_no_angle_change_solid) or bv_character_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_no_angle_change_platform)) 
                {
                    animation_angle = global.gravity_angle;
                    miles_tail_angle = global.gravity_angle;
                    exit;
                }
                else if(abs(angle-animation_angle)&lt;45)
                { 
                    animation_angle = bv_character_rotate_towards(angle, animation_angle, max(1, abs(x_speed)));
                }
                else 
                {
                    animation_angle = angle; 
                }
            }
            else animation_angle = bv_character_rotate_towards(global.gravity_angle, animation_angle, 4);
        }
        
      // Set the Angle of Miles tail.
        if((state = CS_JUMP || state = CS_ROLL || animation_index = "ROLL"))
        {
            if(ground == true)
            {
                miles_tail_angle = angle_relative;
            }
            if(ground == false)
            {
                miles_tail_angle = point_direction(xprevious, yprevious, x, y);
                if(miles_tail_direction != 1)
                {
                   miles_tail_direction = 1;
                }
            } 
        }    
        else
        {
            miles_tail_angle = animation_angle;
        }   
        
     // Set the Tail direction.
        if(ground)
        {
           if(x_speed &lt;&gt; 0)
           {
              miles_tail_direction = sign(x_speed);
           }
           else miles_tail_direction = animation_direction;
        }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platform reset.
 // In order to prevent the player from bouncing off or loosing collision on platform, wait at least 30 frames before reseting the check.
    
    if((ground == false || place_meeting(x, y, par_platform) == false) &amp;&amp; platform_check == 1)
    {
       if(platform_timer &gt; 0)
       {
          platform_timer -= 1;
       }
       else if(platform_timer &lt;= 0)
       {
               platform_check = 0;
               platform_timer = 30;
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Water splash.

    if(stg.zone_water_position != -1)
    {
       if ((abs(y_speed) &gt;= 0)
       &amp;&amp; ((y &gt; stg.zone_water_position &amp;&amp; previous_y &lt; stg.zone_water_position)
       ^^  (y &lt; stg.zone_water_position &amp;&amp; previous_y &gt; stg.zone_water_position)))
       {
           dummy_effect_create(spr_water_splash, 0.3, x, stg.zone_water_position-8, -999995, 0);
           bv_audio_play(_general_water_splash, global.sfx_volume);    
           bv_character_handle_watersurface();      
       }
    }

    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Visual Effects.

 // Afterimage. (Speedshoes, Invincibility)
    if(afterimage_draw == true)
    {
       if(afterimage_timer == 0 &amp;&amp; instance_number(obj_character_afterimage) &lt; 4)
       {
          afterimage_timer = 3;
          with(instance_create(floor(draw_x), floor(draw_y), obj_character_afterimage))
          {
               epic_timer = 5;
               sprite_index = other.animation_sprite_id;
               image_xscale = other.animation_direction;
               image_yscale = 1;
               image_angle  = other.animation_angle;
               image_speed  = 0;
               image_index  = floor(other.animation_frame);
               switch(other.character_id)
               {
                    case CHAR_SONIC:
                    char_pal     = pal_sonic_afterimage;
                    break;
                    case CHAR_TAILS:
                    char_pal     = pal_tails_afterimage;
                    break;
                    case CHAR_KNUX:
                    char_pal     = pal_knux_afterimage;
                    break;
                    case CHAR_AMY:
                    char_pal     = pal_amy_afterimage;
                    break;
                    case CHAR_SHADOW:
                    char_pal     = pal_shadow_afterimage;
                    break;
               }
               depth        = other.depth+1;
          }
       }
       if(afterimage_timer &gt; 0)
       {
          afterimage_timer -= 1;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Receive Inputs.
if(cant_move = true){exit};
    if(character_is_cpu == false)
    {
       bv_character_input_check();
    }
    else
    {
       // bv_character_input_cpu();
    }

 // Disable input if both left and right is being held.
    if(input_left &amp;&amp; input_right)
    {
       input_left  = false;
       input_right = false;
    }
    
 // Input alarm.
    if(input_alarm)
    {
       if(input_alarm_dir == 1)
       {
          input_right = false;
       }
       if(input_alarm_dir == -1)
       {
          input_left = false;
       }
    }
    
 // Input locks (spring)
    if(input_lock_l)
    {
       input_left = false;
    }
    if(input_lock_r)
    {
       input_right = false;
    }
    
// Count input checks.
      if(input_up_pressed)
      {
         input_up_count += 1;
         if(input_up_mtimer != 20) input_up_mtimer = 20;
      }
      if(input_up_mtimer &gt; 0)
      {
         input_up_mtimer -= 1;
      }
      else
      {
         input_up_count = 0;
      }
                
      if(input_down_pressed)
      {
         input_down_count += 1;
         if(input_down_mtimer != 20) input_down_mtimer = 20;
      }
      if(input_down_mtimer &gt; 0)
      {
         input_down_mtimer -= 1;
      }
      else
      {
         input_down_count = 0;
      }
                
      if(input_left_pressed)
      {
         input_left_count += 1;
         if(input_left_mtimer != 20) input_left_mtimer = 20;
      }
      if(input_left_mtimer &gt; 0)
      {
         input_left_mtimer -= 1;
      }
      else
      {
         input_left_count = 0;
      }
                
      if(input_right_pressed)
      {
         input_right_count += 1;
         if(input_right_mtimer != 20) input_right_mtimer = 20;
      }
      if(input_right_mtimer &gt; 0)
      {
         input_right_mtimer -= 1;
      }
      else
      {
         input_right_count = 0;
      }
                
      if(input_action_pressed)
      {
         input_action_count += 1;
         if(input_action_mtimer != 20) input_action_mtimer = 20;
      }         
      if(input_action_mtimer &gt; 0)
      {
         input_action_mtimer -= 1;
      }
      else
      {
         input_action_count = 0;
      }           
      
      if(input_special_pressed)
      {
         input_special_count += 1;
         if(input_special_mtimer != 20) input_special_mtimer = 20;
      }          
      if(input_special_mtimer &gt; 0)
      {
         input_special_mtimer -= 1;
      }
      else
      {
         input_special_count = 0;
      }
           
   // Rail Timer
   /*
      if(rail_timer &gt; 0)
      {
         rail_timer -=1;
      }
      else
      {
         rail_timer = 0;
      }
      if(rail_timer = 0)
      {
         rail_collision = false;
      }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change Physics / Previous Position.

 // Previous Positions:
    previous_x = x;
    previous_y = y;
    
 // Switch Physic Modes:
    if(stg.zone_water_position != -1)
    {
       if(y &lt; stg.zone_water_position)
       {
          if(physic_state != 0)
          {
             physic_state = 0
          }
       } 
       if(y &gt; stg.zone_water_position)
       {
          if(physic_state != 1)
          {
             physic_state = 1;
          }   
       }   
    }

 // Get physic value:
    switch(character_id)
    {
        case CHAR_SONIC:
        {
            bv_physics_get_sonic();
            break;
        }
        case CHAR_TAILS:
        {
            bv_physics_get_tails();
            break;
        }
        case CHAR_KNUX:
        {
            bv_physics_get_knux();
            break;
        }
        case CHAR_AMY:
        {
            bv_physics_get_amy();
            break;
        }
        case CHAR_SHADOW:
        {
            bv_physics_get_shadow();
            break;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death.

    if(death_timer != -1)
    {
       if(state == CS_DEATH)
       {
          // Trigger death state. (Set actual timer and throw the character into the air (if not underwater))
             if(death_timer == -5)
             {
                global.add_time = false;
                if(physic_state == 0)
                {  
                   y_speed = -4;
                }
                angle       = 0;
                death_timer = 128;
                depth       = -999995;
                
                // Fade out the background music.
                   with(ctr_audio)
                   {
                        fadeout_flag = 1;
                   }
                   
                // Decrease lives:
                   global.clives -= 1;
                   if(global.clives &lt; 0) global.clives = 0;
                   
                // Play death/drown sound.
                   if(has_drowned == false)
                   {
                      bv_audio_play(_char_hurt, global.sfx_volume);
                   }
                   else
                   {
                      bv_audio_play(_char_drown, global.sfx_volume);
                   }
                
                // Destroy shields.
                   shield_index = 0;     
                   
                // Stop sound effects.
                   if(bv_audio_is_playing(_char_flying) == true)
                   {
                      bv_audio_stop(_char_flying);
                   }                           
             }
             
          // Gravity:
             if(physic_state == 0)
             {
                y_speed += 0.21875;
             }
             else
             {
                y_speed += 0.0625;
             }
             y += y_speed;
             
          // Decrease timer.
             if(death_timer &gt; 0)
             {
                death_timer -= 1;
             }
             else if(death_timer == 0)
             {
                     death_timer = -1;
                     if(global.clives != 0)
                     {
                        with(instance_create(0, 0, obj_fade_to))
                        {
                             fade_to = room;
                        }
                     }
                     else
                     {
                        with(instance_create(0, 0, obj_fade_to))
                        {
                             fade_to = -1;
                        }                                             
                        global.checkpoint_x = -1;
                        global.checkpoint_y = -1;
                        global.checkpoint_t =  0;  
                     }
             }
       }
    }

 // Trigger death by reaching the death position. 
    if(stg.zone_death_position != -1)
    {
       if(y &gt;= stg.zone_death_position)
       {
          if(state != CS_DEATH)
          {
             state = CS_DEATH;
          }
       }
    }
    else
    {
       if(y &gt;= room_height)
       {
          if(state != CS_DEATH)
          {
             state = CS_DEATH;
          }
       }    
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collision &amp; Instance Detection.
 // Handles how the character interacts with collision and instances.

 // Only run this script if the character has not died and is initialized.
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
    
       // Slope fix for platforms:
       /*
          It was possible to jump-through sloped platforms due to the collision check, checking if the character is actually on ground-
          This additional collision check will fix this issue by setting a flag once the character is near the platform.
       */
          if(bv_character_collision_check(COL_SLOPE_PLATFIX, spr_mask_platform_checker, x, y, angle))
          {
             platform_mode = 1;
          }
          else
          {
             platform_mode = 0;
          }    
                                 
       // Horizontal block:
       // _____________________________________________________________________________________________________________
              
       // Set temp. variable for samples:
          var _samples, _steps;
          
       // Limit the characters horizontal speed.
          if(x_speed_limit == true)
          {
             x_speed = clamp(x_speed, -x_speed_max, x_speed_max);
          }
          
       // Set samples:
          _steps = 1;
          if(x_sample &gt; 0)
          {
             _steps += floor(abs(x_speed)/x_sample);
          }
          _samples = x_speed/_steps;
       
       // Interact horizontally:
          repeat(_steps)
          {
                 // Set Position according to angle.
                    x += dcos(angle)*_samples;
                    y -= dsin(angle)*_samples;
                    
                 // Move the character outside of terrain, if stuck.
                    while(_samples &gt; 0 &amp;&amp; (bv_character_collision_check(COL_RIGHT, MASK_MID, x, y, angle) == true))
                    { 
                          x -= dcos(angle);
                          y += dsin(angle);
                    }
                    while(_samples &lt; 0 &amp;&amp; (bv_character_collision_check(COL_LEFT, MASK_MID, x, y, angle) == true))
                    { 
                          x += dcos(angle);
                          y -= dsin(angle);
                    }
                    
                 // Handle instances:
                    bv_character_handle_list();       
                    
                 // Terrain / Slopes:                 
                    if(ground == true)
                    {
                       while(bv_character_collision_check(COL_MAIN, x, y))
                       {
                             x -= dsin(angle);
                             y -= dcos(angle);
                       }
                       if(bv_character_collision_check(COL_SLOPE, MASK_MID, x, y, angle))
                       {
                          while(!bv_character_collision_check(COL_MAIN, x, y))
                          {
                                x += dsin(angle);
                                y += dcos(angle);
                          }
                       }
                       
                       // Receive new angles:
                          if(y_allow == true)
                          {
                             if(f_edge_skip == 0)
                             {
                                if(bv_character_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; bv_character_collision_check(COL_RIGHT_EDGE, x, y, angle))
                                {
                                   if(f_edge_exception == 1)
                                   {
                                      angle_test = bv_character_calculate_angle(x, y, angle);
                                      if(angle_test &gt;= 60 &amp;&amp; angle_test &lt;= 90 || angle_test &gt;= 240 &amp;&amp; angle_test &lt;= 300)
                                      {
                                         if(!bv_character_collision_check(COL_EDGE_LINE))
                                         {       
                                            ground = false;                                         
                                            break;
                                         }
                                         else angle = angle_test;
                                      }   
                                   }
                                   else angle = bv_character_calculate_angle(x, y, angle);                          
                                }
                             }
                             else
                             {
                                   if(f_edge_exception == 1)
                                   {
                                      angle_test = bv_character_calculate_angle(x, y, angle);
                                      if(angle_test &gt;= 60 &amp;&amp; angle_test &lt;= 90 || angle_test &gt;= 240 &amp;&amp; angle_test &lt;= 300)
                                      {
                                         if(!bv_character_collision_check(COL_EDGE_LINE))
                                         {     
                                            ground = false;                                         
                                            break;
                                         }
                                         else angle = angle_test;
                                      }   
                                   }
                                   else angle = bv_character_calculate_angle(x, y, angle); 
                             }
                          }
                    }
                    
                 // Handle instances:
                    bv_character_handle_list();                                                           
                                                            
                 // Abort:
                    if(x_speed == 0)
                    {
                       break;
                    }   
          }
          
       // Vertical block:
       // _____________________________________________________________________________________________________________
       
       // Set temp. variable for samples:
          var _ysamples, _ysteps;
          
       // Limit the characters horizontal speed.
          if(y_speed_limit == true)
          {
             y_speed = clamp(y_speed, -y_speed_max, y_speed_max);
          }
          
       // Set samples:
          if(ground == false)
          {
             _ysteps = 1;
             if(y_sample &gt; 0)
             {
                _ysteps += floor(abs(y_speed)/y_sample);
             }
             _ysamples = y_speed/_ysteps;      
          } 
     
       // Interact vertically:          
          if(ground == false)
          {
             repeat(_ysteps)
             {
                 // Set Position according to angle.
                    x += dsin(angle)*_ysamples;
                    y += dcos(angle)*_ysamples;
                    
                 // Move the character outside of terrain, if stuck.
                    while(_ysamples &lt; 0 &amp;&amp; (bv_character_collision_check(COL_TOP, MASK_MID, x, y, 0) == true)) 
                    {
                          x += dsin(angle);
                          y += dcos(angle);
                    }
                    while(_ysamples &gt; 0 &amp;&amp; (bv_character_collision_check(COL_BOTTOM, MASK_MID, x, y, 0) == true))
                    {
                          x -= dsin(angle);
                          y -= dcos(angle);
                    }       
                    
                 // Handle instances:   
                    bv_character_handle_list();                                                                         
                                                                             
                 // Check for landing on terrain:
                    if(y_speed &gt;= 0 &amp;&amp; bv_character_collision_check(COL_BOTTOM, MASK_BIG, x, y, 0))
                    {
                       // Set new angles:
                          if(f_edge_skip == 0)
                          {
                             if(bv_character_collision_check(COL_LEFT_EDGE, x, y, 0) &amp;&amp; bv_character_collision_check(COL_RIGHT_EDGE, x, y, 0))
                             { 
                                bv_character_set_angle(bv_character_calculate_angle(x, y, angle));
                             } 
                             else
                             {
                                bv_character_set_angle(0);
                             }
                          }
                          else
                          {
                                bv_character_set_angle(bv_character_calculate_angle(x, y, angle));                          
                          }
                          
                       // Check if we landed on obstacles:
                          if(bv_character_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_obstacle))
                          {
                             bv_character_set_angle(0);
                          }
                          
                       // Change horizontal speed once we landed on terrain.
                          if(abs(x_speed) &lt;= abs(y_speed) &amp;&amp; angle_relative &gt;= 22.5 &amp;&amp; angle_relative &lt;= 337.5)
                          {
                             x_speed = -y_speed*sign(dsin(angle_relative));
                             if(angle_relative &lt; 45 || angle_relative &gt; 315)
                             {
                                x_speed *= 0.5;
                             }
                          }
                          
                       // Set ground flag:
                          y_speed = 0;
                          ground  = true;
                          
                       // Return to the default state.
                          if(state != CS_GLIDE &amp;&amp; state != CS_GLIDE_DROP &amp;&amp; state != CS_SLIDE)
                          {
                             if(state != CS_HURT || state != CS_JUMP)
                             {
                                state = CS_DEFAULT;
                             }
                          }
                          
                       // Return to normal state after flying.
                          if(state == CS_FLY || state == CS_FLYDROP)
                          {
                             state          = CS_DEFAULT;
                             y_acceleration = y_common_acceleration;
                          }                  
                    }  
                    
                 // Check for ceiling:
                    if((y_speed &lt; 0 &amp;&amp; bv_character_collision_check(COL_TOP, MASK_LARGE, x, y, 0)) &amp;&amp; (!bv_character_collision_check(COL_TOP_OBJECT, MASK_LARGE, x, y, angle, par_obstacle)) &amp;&amp; f_ceiling_movement != 0)
                    {
                       // Set new angle.
                          bv_character_set_angle(180);
                          
                       // Check if it's possible to land on the ceiling:
                          if(bv_character_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; bv_character_collision_check(COL_RIGHT_EDGE, x, y, angle))
                          {
                             // Calculate new angle:
                                bv_character_set_angle(bv_character_calculate_angle(x, y, angle));
                                
                             // If the angle is flat, revert angle back to 0.
                                if(angle_relative &gt; 160 &amp;&amp; angle_relative &lt; 200)
                                {
                                   bv_character_set_angle(0);
                                   y_speed = 0;
                                }
                          
                             // If the angle is not flat, change movement values:
                                x_speed -= dsin(angle)*y_speed
                                
                             // Force y speed to 0.
                                y_speed = 0;
                                
                             // Set ground flag.
                                if(ground == false &amp;&amp; angle != 0 &amp;&amp; state != CS_FLY &amp;&amp; state != CS_FLYDROP)
                                {
                                   ground = true;
                                   if(state != CS_DEFAULT)
                                   {
                                      state = CS_DEFAULT;
                                   }
                                }
                          }
                          else
                          {
                             // Set angle to 0.
                                bv_character_set_angle(0);
                                y_speed = 0;
                                if(ground == false)
                                {
                                   break;
                                }
                          }
                    }
                    
                 // Do another stuck check to prevent any lasting glitches that might occur.
                    while(bv_character_collision_check(COL_RIGHT, MASK_MID, x, y, angle))
                    {
                          x -= dcos(angle);
                          y += dsin(angle);
                    }                   
                    while(bv_character_collision_check(COL_LEFT, MASK_MID, x, y, angle))
                    { 
                          x += dcos(angle);
                          y -= dsin(angle);
                    }
                    
                 // Handle instances:   
                    bv_character_handle_list();                                                                                      
                                        
                 // Abort:
                    if(y_speed == 0)
                    {
                       break;
                    }       
             }
          }  
          
       // Fall / Launch of the tile if the edges are no longer colliding:
          repeat(_steps*2)
          {
                 if(ground == true &amp;&amp; (angle != 0 &amp;&amp; ((x_speed &lt;= 0 &amp;&amp; bv_character_collision_check(COL_LEFT_EDGE, x, y, angle) == false) || (x_speed &gt;= 0 &amp;&amp; bv_character_collision_check(COL_RIGHT_EDGE, x, y, angle) == false))))
                 { 
                    // Launch off slopes:
                       if(f_launch_allow == 1)
                       {
                          if((((angle != 90) &amp;&amp; (angle != 270) &amp;&amp; (angle != 180)) &amp;&amp; f_launch_angle != -1) &amp;&amp; (sign(x_speed) == f_launch_direction &amp;&amp; f_launch_direction != 0))
                          {                                                           
                             // Disable stopping at Walls to properly launch.  
                                disable_wallstop = true;
                                if(alarm[0] == -1)
                                {
                                   alarm[0] = 15;
                                }      
                               
                             // Force new angles:
                                angle_relative = sign(x_speed)*f_launch_angle;
                                angle          = sign(x_speed)*f_launch_angle;
                
                             // Set horizontal and vertical speeds:
                                y_speed = -dsin(angle_relative)*x_speed;
                                x_speed =  dcos(angle_relative)*x_speed;
                             
                             // Disable ground flag:
                                ground = false;
                                                                           
                             // Reforce new angles just to make sure nothing changes trying to launch:
                                angle_relative = sign(x_speed)*f_launch_angle;
                                angle          = sign(x_speed)*f_launch_angle;                                                            
                          }         
                          else // Fall off tile:
                          {
                                  ground  = false;
                                  y_speed = -(dsin(angle)*x_speed);
                                  x_speed =  (dcos(angle)*x_speed);
                          } 
                       }                            
                 }
          }
    
       // Platform snap.
          plato = instance_place(x, bbox_top, par_platform)
          plat = collision_point(x, y-24, plato, true, true)
          if(plat == noone &amp;&amp; bv_character_collision_check(COL_BOTTOM_OBJECT, MASK_BIG, x, y, 0, plato) &amp;&amp; ground == false)
          {
             if((state == CS_JUMP))
             {
                if(y_speed &gt; 0 &amp;&amp; ground == false)
                {
                   repeat(16)
                   {
                          y -= 1;
                   }
                }  
             }  
          } 
                    
       // Receive ground speed:
          bv_character_get_groundspeed();
    }  

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Movement.
 // Handles how the character moves and acts horizontally.
 
 // Only run this script if the character has not died and is initialized.
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
      
       // Ignore left and right input on alarm.
          if(input_alarm != 0)
          { 
             input_alarm -= 1;
          }
          else // Revert alarm.
          {
             input_alarm     = 0;
             input_alarm_dir = 0;
          }
          
       // Revert input alarm if the angle equals 0.
          if(input_alarm != 0 &amp;&amp; angle == 0)
          {
             input_alarm     = 0;
             input_alarm_dir = 0;
          }
          
       // Store Acceleration and deceleration values.
          if(ground == true)
          {
             x_temp_accel    = x_acceleration;
             x_temp_decel    = x_deceleration;
             x_temp_friction = x_temp_accel;
          }
          else
          {
             x_temp_accel    = x_acceleration * 2;
             x_temp_decel    = 0;
             x_temp_friction = 0;
          }
          
       // Run only if x movement is possible.
          if(x_allow = true)
          {
          
             // Decelerate on slopes:
                if(state != CS_SLIDE)
                {
                   if(state == CS_ROLL &amp;&amp; ground == true)
                   {
                      // Rolling up a slope:
                         if((angle_relative &lt; 180 &amp;&amp; x_speed &gt; 0) || (angle_relative &gt; 180 &amp;&amp; x_speed &lt; 0))
                         {
                            x_speed -= dsin(angle_relative)*roll_decel_up;
                         }
                         else // Rolling down a slope:
                         {
                            x_speed -= dsin(angle_relative)*roll_decel_down;
                         }
                   }
                   else // Decelerate normally.
                   {
                           if(ground == true &amp;&amp; ((angle_relative &gt; 35 &amp;&amp; angle_relative &lt; 330) || round(x_speed) != 0 || input_alarm != 0))
                           {
                              x_speed -= dsin(angle_relative)*0.125;
                           }
                   }
                }
                
             // Handle Acceleration/Deceleration.
                if((state == CS_DEFAULT || state == CS_BALANCE || (state == CS_JUMP &amp;&amp; !jump_lock) || state == CS_SKID || state == CS_SPRING || state == CS_SPRING_DIAGONAL || state == CS_FLY || state == CS_FLYDROP || state == CS_GLIDE_DROP) &amp;&amp; (state != CS_GLIDE &amp;&amp; state != CS_SLIDE &amp;&amp; state != CS_CLIMB))
                {
                   if((ground == true))
                   {
                      if(input_left == true &amp;&amp; input_alarm == 0)
                      {
                         if(x_speed &gt; 0)
                         {
                            x_speed -= x_temp_decel;
                            if(x_speed &lt;= 0)
                            {
                               x_speed = -0.5;
                            }
                         }
                         else
                         {
                            if(x_speed &gt; -x_speed_top)
                            {
                               x_speed -= x_temp_accel;
                               if(x_speed &lt;= -x_speed_top)
                               {
                                  x_speed = -x_speed_top;
                               }                               
                            }
                         }
                      }
                      else if(input_right == true &amp;&amp; input_alarm == 0)
                      {
                              if(x_speed &lt; 0)
                              {
                                 x_speed += x_temp_decel;
                                 if(x_speed &gt;= 0)
                                 {                                 
                                    x_speed = 0.5;
                                 }   
                              }
                              else
                              {
                                 if(x_speed &lt; x_speed_top)
                                 {
                                    x_speed += x_temp_accel;
                                    if(x_speed &gt;= x_speed_top)
                                    {
                                       x_speed = x_speed_top;
                                    }
                                 }
                              }
                      }
                      else if(input_alarm == 0)
                      {
                              x_speed -= min(abs(x_speed), x_temp_friction)*sign(x_speed);
                      }
                   }
                   else
                   {
                      // Air acceleration
                         if(input_left)
                         {
                            if(state == CS_FLY || state == CS_FLYDROP || state == CS_GLIDE_DROP)
                            {
                               if(x_speed &gt; 0)
                               {
                                  x_speed -= x_temp_accel;
                               }
                               else if(x_speed &gt; -x_speed_top)
                               {
                                       x_speed -= x_air_accel;
                               }                      
                            }
                            else
                            {                             
                               if(x_speed &gt; 0)
                               {
                                  x_speed -= x_temp_accel;
                               }
                               else if(x_speed &gt; -x_speed_top)
                               {
                                       x_speed -= x_air_accel;                               
                                       if(x_speed &lt;= -x_speed_top) x_speed = -x_speed_top;
                               }
                             }
                         }
                         else if(input_right)
                         {
                            if(state == CS_FLY || state == CS_FLYDROP || state == CS_GLIDE_DROP)
                            {
                               if(x_speed &lt; 0)
                               {
                                  x_speed += x_temp_accel;
                               }
                               else if(x_speed &lt; x_speed_top)
                               {
                                       x_speed += x_air_accel;
                               }                      
                            }
                            else  
                            {                       
                               if(x_speed &lt; 0)
                               {
                                  x_speed += x_temp_accel;
                               }
                               else if(x_speed &lt; x_speed_top)
                               {
                                       x_speed += x_air_accel;
                                       if(x_speed &gt;= x_speed_top) x_speed = x_speed_top;
                               }
                            }
                         }
                   }
                }
                               
             // Fall if there isn't enough speed to stay on ground.
                if(angle_relative &gt;= 44 &amp;&amp; angle_relative &lt;= 315 &amp;&amp; ground == true &amp;&amp; abs(x_speed) &lt; 2.5 &amp;&amp; tunnel_lock == 0)
                {
                   if(angle_relative &gt;= 90 &amp;&amp; angle_relative &lt;= 270)
                   {
                      y_speed = -dsin(angle_relative)*x_speed;
                      x_speed =  dcos(angle_relative)*x_speed;
                      ground  =  false;
                   }
                   else // Input alarm:
                   {
                      input_alarm = 30;
                      if(input_alarm_dir == 0)
                      {
                         input_alarm_dir = animation_direction;
                      }
                   }
                }  
                               
             // Get new angle:
                if(ground &amp;&amp; bv_character_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; bv_character_collision_check(COL_RIGHT_EDGE, x, y, angle))
                {
                   bv_character_set_angle(bv_character_calculate_angle(x, y, angle));
                }                     
                else
                {
                   bv_character_set_angle(0);
                }
                
             // Full stop when we're colliding with a wall:
                if(!disable_wallstop)
                {
                   if((x_speed &gt; 0 &amp;&amp; bv_character_collision_check(COL_RIGHT, MASK_BIG, x, y, angle)) || (x_speed &lt; 0 &amp;&amp; bv_character_collision_check(COL_LEFT, MASK_BIG, x, y, angle)))
                   {
                      x_speed = 0;
                   }
                }
          }
    
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical Movement.
 // Handles how the character moves and acts vertically.
  
 // Only run this script if the character has not died and is initialized.
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
       // Run only if y movement is possible.
          if(y_allow == true)
          {               
             // Return to a normal state.
                if(ground == true)
                {       
                   if not(y_speed &lt; 0 || state == CS_HURT)
                   {
                          y_speed = 0;
                   }                               
                   if(state == CS_HURT || state == CS_SPRING || state == CS_SPRING_DIAGONAL)
                   {
                      if(state == CS_HURT)
                      {
                         x_speed = 0;
                      }
                      state = CS_DEFAULT;
                   }
                   
                   // Check if the character has not landed:
                      if(bv_character_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle) == false)
                      {
                         ground = false;
                         bv_character_set_angle(0);
                      }
                }
                
             // Add gravity and landing checks:
                if(ground == false)
                {
                   // Gravity:
                      y_speed += y_acceleration;
                   
                   // Check if we've landed on a tile:
                      if(y_speed &gt;= 0 &amp;&amp; bv_character_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle) == true)
                      {
                         // We are grounded.
                            ground = true;
                            
                         // Return to a normal state. 
                            if(state != CS_GLIDE &amp;&amp; state != CS_GLIDE_DROP &amp;&amp; state != CS_SLIDE)
                            {
                               if(state == CS_JUMP || state == CS_FLY || state == CS_FLYDROP || state == CS_HURT)
                               {
                                  if(state == CS_HURT)
                                  {
                                     x_speed = 0;
                                  }
                                  state = CS_DEFAULT;
                               }
                            }
                      }
                      
                   // Check if we colliding with a ceiling. 
                      if(y_speed &lt; 0 &amp;&amp; bv_character_collision_check(COL_TOP, MASK_BIG, x, y, angle) == true)
                      {
                         y_speed = 0;
                         if(state == CS_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; y_speed == 0)
                         { 
                            state = CS_ROLL;
                         }
                      }
                }
                
             // Reset horizontal speed after getting hurt.
                if(y_speed &gt;= 0 &amp;&amp; bv_character_collision_check(COL_BOTTOM, MASK_MAIN, x, y, angle) == true)
                {
                   if(state == CS_HURT)
                   {
                      x_speed = 0;
                      state   = CS_DEFAULT;
                   }
                }
          }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States.
 // if(cant_move = true){exit};

 // Actions unique to Sonic
    if(character_id = CHAR_SONIC)
    {
        // Transform:
        bv_character_state_transform();
        
        // Air dash:
        bv_character_state_airdash();
     
        // Insta-shield:
        bv_character_state_insta_shield();
        
        // Sommersault:
        bv_character_state_sommersault();
    }    
    
 // Actions unique to Sonic and Amy
    if(character_id = CHAR_SONIC || character_id = CHAR_AMY || character_id = CHAR_SHADOW)
    {
        // Grind:
        bv_character_state_grind();
    }
    
 // Actions unique to Tails
    if(character_id = CHAR_TAILS)
    {
        // Flying
        bv_character_state_fly();
        
        // Swipe
        bv_character_state_swipe();
    }
    
 // Actions unique to Knuckles
    if(character_id = CHAR_KNUX)
    {
        // Gliding
        bv_character_state_glide();
        
        // Climb
        bv_character_state_climb();
        
        // Slide
        bv_character_state_slide();
        
        // Attack
        bv_character_state_combo();
        
        // Stroke
        bv_character_state_stroke();
        
        // Stroke Look
        bv_character_state_stroke_look();
        
    }
    
 // Actions unique to Amy
    if(character_id = CHAR_AMY)
    {
        // Hammer attacks
        bv_character_state_hammer();
        
        // Short Hop
        bv_character_state_short_hop();
        
        // Dive
        bv_character_state_dive();
    }
    
 // Actions unique to Shadow
    if(character_id = CHAR_SHADOW)
    {
        // Homing Attack
        bv_character_state_homing();
        
        // Chaos Spear
        bv_character_state_spear();
    }
    
 // Jumping:
    bv_character_state_jump();

 // Look:
    bv_character_state_look();
 
 // Spindash:
    bv_character_state_spindash();
    
 // Roll:
    bv_character_state_roll();
    
 // Crouch:
    bv_character_state_crouch();
    
 // Skid:
    bv_character_state_skid();
 
 // Push:
    bv_character_state_push();
    
 // Balance:
    bv_character_state_balance();
    
 // Cloud Bounce:
    bv_character_state_cloudbounce();
    
 // Pull:
    bv_character_state_pull();
    
 // Goal:
    bv_character_state_goal();
    bv_character_state_goal_capsule();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Air drag &amp; Angle Mode.

 // Exit if not initialized or death.
    if(is_initialized == true &amp;&amp; state != CS_DEATH)
    {   
        // Air Drag:
           if(ground == false &amp;&amp; state != CS_HURT)
           {
              if(y_speed &lt; 0 &amp;&amp; y_speed &gt;= -4)
              {
                 x_speed -= ((x_speed / 0.125) / 256);
              }
           }
    }
    
 // Floor mode:
    slope_ang_mode = round(angle/25)  
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input disabling.

 // Exit if not initialized, death or hurt.
    if(is_initialized == true &amp;&amp; state != CS_DEATH &amp;&amp; state != CS_HURT)
    {    
       // Enable input after jumping:
          if(input_lock_s &amp;&amp; !jump_lock &amp;&amp; state == CS_JUMP)
          {
             input_lock_s    = 0;
             input_lock_l    = 0;
             input_lock_r    = 0;          
             lock_timer      = 0;
             input_alarm_dir = 0;
          }
    
       // Disable direction lock when the angle is equal to 0.
          if(input_alarm_dir != 0 &amp;&amp; angle == 0)
          {
             input_alarm_dir = 0;
          }
    
       // Disable spring lock:
          if(lock_timer &lt; 1 &amp;&amp; input_lock_s == true)
          {
             input_lock_s = 0;
             input_lock_l = 0;
             input_lock_r = 0;
          }
    
       // Enable locks:
          if(input_lock_s &amp;&amp; x_speed &gt; 0)
          {
             input_lock_l = 1;
             input_right  = 1;
          }
          else if(input_lock_s &amp;&amp; x_speed &lt; 0)
          {
                  input_lock_r = 1;
                  input_left   = 1;
          }
    
       // Decrease timers.
          if(lock_timer)
          {
             lock_timer -= 1;
          }
          if(lock_timer &lt; 0)
          { 
             lock_timer = 0;
          }
          
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Invincibility/Speedup Timers.

 // Exit if not initialized or death.
    if(is_initialized == true &amp;&amp; state != CS_DEATH)
    {
        
       // Decrease invincibility timer.
          if(invincibility_timer &gt; -1)
          { 
             invincibility_timer -= 1;
             if(invincibility_timer &lt;= 0)
             {
                invincibility       =  0;
                invincibility_timer = -1;
                if(animation_alpha &lt; 1)
                {
                   animation_alpha = 1;
                }
             }
          } 
    
       // Start timer once we land after being hit.
          if(invincibility == 1 &amp;&amp; invincibility_timer == -1)
          {
             if(ground)
             { 
                invincibility_timer = 120;
             }
             if(state != CS_HURT)
             {
                invincibility_timer = 120;
             }
          }
          
       // Speedshoe timer.
          if(speedshoe_timer &gt; 0)
          {
             speedshoe_timer -= 1;
          }
          else
          {
             if(speedshoe_state == 1)
             {
                speedshoe_state = 0;  
                if(bv_audio_is_playing(_ev_sneakers))
                {
                    bv_audio_stop(_ev_sneakers);
                }                  
             }
          }

       // invincibility sparkles.
        if(invincibility = 2)
        {
           repeat(1)
           {
              if(instance_number(obj_invincibility_spark) &lt; 3)
              {
                 instance_create(x, y, obj_invincibility_spark);
              }
           }
        }
            
       // Stop jingles.
          if(bv_audio_is_playing(_ev_invincibility) &amp;&amp; invincibility == 0)
          { 
             bv_audio_stop(_ev_invincibility);
          }
          
          if(bv_audio_is_playing(_ev_super) &amp;&amp; player_state == PLAYER_NORMAL)
          {
             bv_audio_stop(_ev_super);
          }
    
       // Don't show shields.
          if(shield_index != 0 &amp;&amp; invincibility &gt; 1)
          { 
             if(shield_object != noone)
             {
                shield_object.visible = false;
             }
          }
          else
          {
             if(shield_object != noone)
             {
                shield_object.visible = true;
             }
          }            
          // When we're super, we're always invincible:
          if(player_state = PLAYER_SUPER)
          {
             invincibility          =  2;
             invincibility_timer    = -2;
          }
          else
          {
             if(invincibility_timer = -2)
             {
                invincibility       = 0;
                invincibility_timer = 0;
             }
          } 
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Modify Palette position.

 // Default:
    if(character_id = CHAR_SONIC &amp;&amp; player_state = PLAYER_NORMAL &amp;&amp; transform_ended = 0){
       palette_position = 0;
    }
 
 // Super Sonic Palette:
    if(character_id = CHAR_SONIC &amp;&amp; player_state = PLAYER_SUPER){
       if(palette_position &gt; 2)
       {
          palette_position = 1;
       }
       palette_position += 0.05;
    }
    
 // Back to normal Sonic Palette:
    if(character_id = CHAR_SONIC &amp;&amp; player_state = PLAYER_NORMAL &amp;&amp; transform_ended == 1)
    {
       if(palette_position &gt; 4)
       {
          transform_ended  = 0;
       }
       else
       {
          palette_position += 0.5;
       }
    }
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Underwater / Drowning.

    if(is_initialized == true &amp;&amp; state != CS_DEATH)
    {
       // Check if the player is currently underwater, we do that by checking the physic state.
          if(physic_state == 1)
          {
               // Decrease a timer which, once -130 (normally 0 but manias drown theme is longer), kills the character.
                  if(drown_timer &gt; 0)
                  {
                     drown_timer -= 1;
                  }
                  
               // Start playing the drowning jingle and create the count down.
                  if(drown_timer == 650)
                  {
                     // Audio:
                       if(global.ev_volume != 0.0)
                       {
                          if(bv_audio_is_playing(_ev_drown) == false)
                          {
                             bv_audio_play(_ev_drown, global.ev_volume);
                          }
                       }
                                                
                     // Counter:
                        if(instance_exists(obj_drown_counter) == false)
                        {
                           drown_counter = instance_create(x, y-32, obj_drown_counter);
                           drown_counter . parent = id;
                        }                         
                  }
                  
               // Kill the character.
                  if(drown_timer == 0)
                  {
                    drown_timer = 1800;
                    state       = CS_DEATH;
                    has_drowned = true;                 
                  }
                  
               // Alarm/Beeping sounds:
                  if(drown_timer mod 400 == 0 &amp;&amp; drown_timer &gt; 650)
                  {
                     // Audio thing.
                        bv_audio_play(_general_drown_alert, global.sfx_volume);
                  }
                  
               // Bubble state:
                  if(state != CS_BREATHE)
                  {
                     bubble_timer = 0;
                  }
                  else
                  {
                     if(!ground)
                     {
                        if(bubble_timer &lt; 1)
                        {
                           x_speed         = 0;
                           y_speed         = 0;
                           animation_index = "BREATHE";
                        }       
                        if(input_left || input_right)
                        {
                           x_speed += animation_direction*.025;
                        }        
                        if(bubble_timer &lt; 20)
                        {
                           bubble_timer += 1;
                        }
                        else
                        {
                            bubble_timer    = 0;
                            state           = CS_DEFAULT;
                        }
                        drown_timer = 1800;
                        if(instance_exists(drown_counter))
                        {
                            with(drown_counter)
                            {
                                 instance_destroy();
                            }
                            drown_counter = noone;
                        }                  
                        // Stop drowning sound:       
                           if(bv_audio_is_playing(_ev_drown))
                           {
                              bv_audio_stop(_ev_drown);
                           }                                                                    
                     }
                     else
                     {
                        state       = CS_DEFAULT;
                        drown_timer = 1800;
                        if(instance_exists(drown_counter))
                        {
                            with(drown_counter)
                            {
                                instance_destroy();
                            }
                            drown_counter = noone;
                        }
              
                        // Stop drowning sound:       
                            if(bv_audio_is_playing(_ev_drown))
                            {
                               bv_audio_stop(_ev_drown);
                            }                          
                     }
                  }
                  
               // Air bubbles:
                  if(drown_timer mod 80 == 0 &amp;&amp; drown_timer &gt; 650)
                  {
                     // Bubble:
                        with(instance_create(x+irandom_range(-7, 8), y-6, obj_water_bubble_small))
                        {
                             max_frame = choose(0, 3, 8);
                        }
                  }    
            }
            else // Reset timers and destroy the drown counter, if it exists.
            { 
                 drown_timer = 1800;
                 if(instance_exists(drown_counter))
                 {
                    with(drown_counter)
                    {
                         instance_destroy();
                    }
                    drown_counter = noone;
                 }
              
              // Stop drowning sound:       
                 if(bv_audio_is_playing(_ev_drown))
                 {
                    bv_audio_stop(_ev_drown);
                 }     
            }          
      }
      else // Above water, reset flags.
      {
              drown_timer = 1800;
              if(instance_exists(drown_counter))
              {
                 with(drown_counter)
                 {
                      instance_destroy();
                 }
                 drown_counter = noone;
              }
              
           // Stop drowning sound:       
              if(bv_audio_is_playing(_ev_drown))
              {
                 bv_audio_stop(_ev_drown);
              }                             
      }
    
 // Drowning bubbles.
    if(state == CS_DEATH &amp;&amp; has_drowned == true)
    {
       if(breath_timer != 0)
       {  
          breath_timer -= 1;
          if(random(4) &gt;= 2)
          {
             bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_water_bubble_small);
             bubble . max_frame = choose(0, 1, 3, 8);
             bubble . depth     = -999995;             
          }
       }
    }    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Speed Caps.
 // Add your own speed caps here.
 
 // Ground cap:
    if(x_speed &gt; 14)
    {
       x_speed = 14;
    }
                         
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stop the after image if you're homing
if(ground &amp;&amp; state = CS_HOMING or state = CS_JUMP)
{
    afterimage_draw = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>pal_swap_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drawing.
 // This script will handle the drawing of the character.
 
 // Super Sonic Palette
    if(character_id = CHAR_SONIC &amp;&amp; player_state = PLAYER_SUPER)
    {
        pal_swap_set(pal_super_sonic, palette_position, false);
    }
    if(character_id = CHAR_SONIC &amp;&amp; player_state = PLAYER_NORMAL &amp;&amp; transform_ended == 1)
    {
        pal_swap_set(pal_sonic_to_normal, floor(palette_position), false);
    }      
    
 // Flickering:         
    if(invincibility == 1 &amp;&amp; invincibility_timer &gt; 0)
    {
       if((global.game_time div 60) mod 3)
       {
          if(miles_tail_sprite != noone)
          {
             draw_sprite_ext(miles_tail_sprite, floor(miles_tail_frame), floor(x+miles_tail_x), floor(y+miles_tail_y), miles_tail_direction, 1, miles_tail_angle, animation_blend, animation_alpha); 
          }         
          draw_sprite_ext(animation_sprite_id, floor(animation_frame), floor(draw_x), floor(draw_y), animation_direction, 1, animation_angle, animation_blend, animation_alpha);
       }
    }
    else
    {
       // Normal Draw: 
          if(miles_tail_sprite != noone)
          {
             draw_sprite_ext(miles_tail_sprite, floor(miles_tail_frame), floor(x+miles_tail_x), floor(y+miles_tail_y), miles_tail_direction, 1, miles_tail_angle, animation_blend, animation_alpha); 
          }        
          draw_sprite_ext(animation_sprite_id, floor(animation_frame), floor(draw_x), floor(draw_y), animation_direction, 1, animation_angle, animation_blend, animation_alpha);
    }
    
 // Spindash dust:
    if(state == CS_SPINDASH)
    { 
       if(spindash_frame &lt; 11-0.48)
       {
          spindash_frame += 0.48;
       }
       else
       {
          spindash_frame = 4;
       }
       draw_sprite_ext(spr_char_spindash_dust, floor(spindash_frame), floor(draw_x-animation_direction*1), floor(draw_y), animation_direction, 1, 0, c_white, animation_alpha);    
    }
 
 // Stroke splashing:
    if(state == CS_STROKE)
    {
        draw_sprite_ext(spr_char_knux_swim_effect, current_time div 100, floor(draw_x-animation_direction*1), floor(draw_y-9), animation_direction, 1, 0, c_white, animation_alpha);
    }
    
    /*
    draw_set_font(fnt_ass);
    draw_set_halign(fa_right);
    draw_text(view_xview+224, view_yview+2, state);
    draw_text(view_xview+224, view_yview+18, amy_hammer_attack);
    draw_text(view_xview+224, view_yview+34, combo_state);
    draw_text(view_xview+224, view_yview+50, floor(x_speed));
    draw_text(view_xview+224, view_yview+66, floor(y_speed));
    draw_text(view_xview+224, view_yview+82, move_alarm);
    draw_text(view_xview+224, view_yview+98, x);
    draw_text(view_xview+224, view_yview+114, y);
    draw_text(view_xview+224, view_yview+130, stg.zone_water_position);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
